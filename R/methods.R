##Experiment
#' @export
'[[.Experiment' <- function(x, i, name = TRUE, drop = TRUE) x$get(i)
#' @export
detector_names.Experiment <- function(x) return(x$detector_names)
#' @export
plate_names.Experiment <- function(x) return(x$plate_names)
#' @export
sample_names.Experiment <- function(x) return(x$sample_names)
#' @export
n_samples.Experiment <- function(x) length(sample_names(x))
#' @export
n_plates.Experiment <- function(x) length(plate_names(x))
#' @export
n_detectors.Experiment <- function(x) length(detector_names(x))
#' @export
'[.Experiment' <- function(x, detectors, samples, plates, name = TRUE, drop = TRUE){
    # TODO: Warn when detectors/samples/plates not found.
    s <- Sys.time()
    plate_list <- x[['plates']]
    detector_idx = c(T)
    sample_idx = c(T)
    plate_idx = c(T)
    # Filter plates first...
    if(!missing(plates)){
        pn <- plate_names(x)
        stopifnot(all(plates %in% pn))
        plate_idx <- pn %in% plates
    }
    plate_list <- plate_list[plate_idx]
    new_plate_list <- list()
    for(plate_idx in seq_along(plate_list)){
        mod_plate <- plate_list[[plate_idx]]
        details <- list('BarCode' = plate_name(mod_plate))
        if(!missing(detectors)){
            detector_idx <- detector_names(mod_plate) %in% detectors
        }
        if(!missing(samples)){
            sample_idx <- sample_names(mod_plate) %in% samples
        }
        well_list <- mod_plate[['wells']][detector_idx & sample_idx]
        new_plate_list[[names(plate_list)[plate_idx]]] <- Plate$new(well_list, details=details)
    }
    newx = Experiment$new(plates=new_plate_list, input_directory=x[['input_directory']], history=x[['history']])
    updateHistory(newx, timepoint0=s, message=glue::glue("Subset to {n_plates(newx)} plates, {n_samples(newx)} samples, {n_detectors(newx)} detectors"))
    return(newx)
}

## Plate
#' @export
'[[.Plate' <- function(x, i, name = TRUE, drop = TRUE) x$get(i)
#' @export
sample_names.Plate <- function(x) return(x$sample_names)
#' @export
plate_name.Plate <- function(x) return(x$plate_name)
#' @export
detector_names.Plate <- function(x) return(x$detector_names)

## Well

#' @export
'[[.Well' <- function(x, i, name = TRUE, drop = TRUE) x$get(i)
#' @export
detector_name.Well <- function(x) return(x[['Detector']])
#' @export
sample_name.Well <- function(x) return(x[['Sample']])
#' @export
plate_name.Well <- function(x) return(x[['Plate']])



## Generics
#' @export
sample_names <- function(x) UseMethod("sample_names", x)
#' @export
detector_names <- function(x) UseMethod("detector_names", x)
#' @export
detector_name <- function(x) UseMethod("detector_name", x)
#' @export
sample_name <- function(x) UseMethod("sample_name", x)
#' @export
plate_name <- function(x) UseMethod("plate_name", x)
#' @export
plate_names <- function(x) UseMethod("plate_names", x)
#' @export
n_samples <- function(x) UseMethod("n_samples", x)
#' @export
n_detectors <- function(x) UseMethod("n_detectors", x)
#' @export
n_plates <- function(x) UseMethod("n_plates", x)




#' Update History of miRoar class object
#'
#' Update History generic
#'
#' @param x character, The file name to be read in
#' @param timepoint0 Logical, whether or not some message are output
#' @param message Logical, controlled by 
#' 
#' @return x
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
updateHistory <- function(x, timepoint0, message) UseMethod("updateHistory", x)
#' @export
updateHistory.Experiment <- function(x, timepoint0, message){
    x$updateHistory(timepoint0, message)
    return(x)
}














#' Update History of miRoar class object
#'
#' Update History of miRoar class object
#'
#' @param x character, The file name to be read in
#' @param timepoint0 The timepoint as generated by Sys.time()
#' @param message The message you wish to store
#' 
#' @return x with the history updated with the specified method.
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
updateHistory.miRoar <- function(x, timepoint0, message){
    x$history <- as.data.frame(rbind(x$history, 
                        data.frame('Submitted' = timepoint0, 
                        'Finished' = Sys.time(), 
                        'Comment' = message)), stringsAsFactors=F)
    return(x)
}


#' Calculate delta Ct values from CT values using a variety of methods
#'
#' Calculate delta Ct values using global, endogenous, genorm or normfinder
#'
#' @param ct character, The file name to be read in
#' @param which Which Ct matrix should be normalised ('Ct', 'Crt' or 'CtAvg')
#' @param method Logical, whether or not some message are output
#' @param HKs Logical, controlled by 
#' @param group Factor describing the groups each sample belongs to
#' @param ... Other parameters I have forgotten
#' 
#' @return deltaCT values
#'
#' @examples
#' # readEDSfile()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
deltaCt.miRoar <- function(ct, 
                    method = c('global', 'endogenous','geNorm', 'NormFinder'), 
                    HKs = NULL, 
                    group = NULL,
                    ...
                    ){
    t0 <- Sys.time()
    # These should be done outside!
    ct2 <- ct$CtAvg
    
    amp <- ct$CrtAmp
    is.na(ct2) <- ct2 <= 0 | ct2 >= 40
    is.na(ct2) <- amp == -1
    ct3 <- ct2#[!duplicated(rownames(ct2)),]
    dct <- deltaCt(ct3, method = method, HKs = HKs, group = group, ...)
    message('Adding dCT to miRoar object')
    ct$dCT <- dct
    ct <- updateHistory(ct, t0, sprintf('Calculate deltaCT using %s', method))
    return(ct)
}

#' Subset miRoar object
#'
#' Subset miRoar object
#'
#' @param x object to be subsetted
#' @param i row index
#' @param j col index
#' 
#' @return subsetted miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
subset.miRoar <- function(x, i, j){
    s <- Sys.time()
    history <- x$history
    new <- lapply(x[-which(names(x) == 'history')], function(a, i, j){
        if(is.matrix(a)) return(a[i,j])
        else if(is.array(a)) return(a[i,,j])
        else return(a[j])
        }, i=i, j=j)
    new$history <- history
    class(new) <- 'miRoar'
    newdim <- dim(new[[1]])
    new <- updateHistory(new, s, sprintf('Created subset with %s miRs and %s samples', newdim[1], newdim[2]))
    return(new)
}

#' Print miRoar object
#'
#' Print miRoar object
#'
#' @param x object to be printed
#' 
#' @return printed miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
print.miRoar <- function(x){
    message('Contains:')
    for(i in names(x)) message('\t ', i)
    message(nrow(x),' miRs x ',ncol(x), ' samples')
    print(x$history)
}

#' dim miRoar object
#'
#' dim miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return Dimensions
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
dim.miRoar <- function(x){
    dim(x[['CtAvg']])
}

#' nrow miRoar object
#'
#' nrow miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return nrow miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
nrow.miRoar <- function(x) dim(x)[1]

#' ncol miRoar object
#'
#' ncol miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return subsetted miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
ncol.miRoar <- function(x) dim(x)[2]

#' rownames miRoar object
#'
#' rownames miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return rownames miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
getRownames <- function(x) rownames(x[['CtAvg']])

#' colnames miRoar object
#' colnames miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return colnames miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
getColnames <- function(x) colnames(x[['CtAvg']])

# broken
collapseMultipleReadings.miRoar <- function(x, method=c('mean', 'median'), na.rm=T){
    s <- Sys.time()
    history <- x$history
    method <- match.arg(method)

    woot <- lapply(x[-which(names(x) == 'history')], function(y, method, na.rm){
            if(is.matrix(y)){
                rn <- rownames(y)
                new <- t(sapply(unique(rn), function(i, y, method, na.rm){
                            res <- switch(method, 
                                'mean' = colMeans(t(as.matrix(y[rownames(y) %in% i, , drop=F])), na.rm=na.rm),
                                'median' = colMedians(t(as.matrix(y[rownames(y) %in% i,,drop=F])), na.rm=na.rm))
                            return(res)
                        },y=y, method=method, na.rm=na.rm))
                return(new)
            } else if(is.array(y)){
                rn <- rownames(y)
                new <- t(sapply(unique(rn), function(i, y, method, na.rm){
                            res <- switch(method, 
                                'mean' = colMeans(as.matrix(y[rownames(y) %in% i,, ,drop=F]), na.rm=na.rm),
                                'median' = colMedians(as.matrix(y[rownames(y) %in% i,,,drop=F]), na.rm=na.rm))
                            return(res)
                        },y=y, method=method, na.rm=na.rm))
                return(new)
            } else {
                return(y)
            }}, method=method, na.rm=na.rm)
    woot$history <- history
    class(woot) <- 'miRoar'
    woot <- updateHistory(woot, s, 'Used collapseMultipleReadings')
    return(woot)
}

#' Set Bad Signals to NA
#'
#' Set Bad Signals to NA
#'
#' @param x a miRoar object
#' @param maxCT a
#' @param minCT b
#' @param ampVal c
#' @param conf.val d
#' @return x
#'
#' @examples
#' # readEDSfile()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
setBadSignalsToNA.miRoar <- function(x, maxCT = 40, minCT = 0, ampVal = 0, conf.val = .8){
    s <- Sys.time()
    detp <- x$Con
    amps <- x$CrtAmp
    crts <- x$Crt
    toNA <- detp < conf.val | amps < ampVal | crts <= minCT | crts >= maxCT
    is.na(x$Ct) <- toNA
    is.na(x$CtAvg) <- toNA
    is.na(x$Crt) <- toNA
    x <- updateHistory(x, s, 'Set values to NA using thresholds:')
    return(x)
}

#' Remove Bad Signals
#'
#' Remove Bad Signals
#'
#' @param x a miRoar object
#' @param perc a
#' @return x
#'
#' @examples
#' # readEDSfile()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
removeBadSignals <- function(x, perc = 1) UseMethod('removeBadSignals', x)

#' Remove Bad Signals
#'
#' Remove Bad Signals
#'
#' @param x a miRoar object
#' @param perc a
#' @return x
#'
#' @examples
#' # readEDSfile()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
removeBadSignals.miRoar <- function(x, perc = 1){
    s <- Sys.time()
    z <- rowSums(is.na(x[['Crt']]))
    thresh <- ncol(x)*perc
    xx <- subset(x, i = !z >= 1)
    xx <- updateHistory(xx, s, 'Removed miRs with no signal')
    return(xx)
}

