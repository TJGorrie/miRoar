#' Update History of miRoar class object
#'
#' Update History of miRoar class object
#'
#' @param x character, The file name to be read in
#' @param timepoint0 The timepoint as generated by Sys.time()
#' @param message The message you wish to store
#' 
#' @return x with the history updated with the specified method.
#'
#' @examples
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export

updateHistory.miRoar <- function(x, timepoint0, message){
    x$history <- as.data.frame(rbind(x$history, 
                        data.frame('Submitted' = timepoint0, 
                        'Finished' = Sys.time(), 
                        'Comment' = message)), stringsAsFactors=F)
    return(x)
}

#' Calculate delta Ct values from CT values using a variety of methods
#'
#' Calculate delta Ct values using global, endogenous, genorm or normfinder
#'
#' @param ct character, The file name to be read in
#' @param which Which Ct matrix should be normalised ('Ct', 'Crt' or 'CtAvg')
#' @param method Logical, whether or not some message are output
#' @param HKs Logical, controlled by 
#' @param group Factor describing the groups each sample belongs to
#' @param ... Other parameters I have forgotten
#' 
#' @return deltaCT values
#'
#' @examples
#' # readEDS()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
deltaCt.miRoar <- function(ct, 
                    method = c('global', 'endogenous','geNorm', 'NormFinder'), 
                    HKs = NULL, 
                    group = NULL,
                    ...
                    ){
    t0 <- Sys.time()
    # These should be done outside!
    ct2 <- ct$CtAvg
    
    amp <- ct$CrtAmp
    is.na(ct2) <- ct2 <= 0 | ct2 >= 40
    is.na(ct2) <- amp == -1
    ct3 <- ct2#[!duplicated(rownames(ct2)),]
    dct <- deltaCt(ct3, method = method, HKs = HKs, group = group, ...)
    message('Adding dCT to miRoar object')
    ct$dCT <- dct
    ct <- updateHistory(ct, t0, sprintf('Calculate deltaCT using %s', method))
    return(ct)
}

#' Subset miRoar object
#'
#' Subset miRoar object
#'
#' @param x object to be subsetted
#' @param i row index
#' @param j col index
#' 
#' @return subsetted miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
subset.miRoar <- function(x, i, j){
    s <- Sys.time()
    history <- x$history
    new <- lapply(x[-which(names(x) == 'history')], function(a, i, j){
        if(is.matrix(a)) return(a[i,j])
        else if(is.array(a)) return(a[i,,j])
        else return(a[j])
        }, i=i, j=j)
    new$history <- history
    class(new) <- 'miRoar'
    newdim <- dim(new[[1]])
    new <- updateHistory(new, s, sprintf('Created subset with %s miRs and %s samples', newdim[1], newdim[2]))
    return(new)
}

#' Print miRoar object
#'
#' Print miRoar object
#'
#' @param x object to be printed
#' 
#' @return printed miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
print.miRoar <- function(x){
    message('Contains:')
    for(i in names(x)) message('\t ', i)
    message(nrow(x),' miRs x ',ncol(x), ' samples')
    print(x$history)
}

#' dim miRoar object
#'
#' dim miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return Dimensions
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
dim.miRoar <- function(x){
    dim(x[['CtAvg']])
}

#' nrow miRoar object
#'
#' nrow miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return nrow miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
nrow.miRoar <- function(x) dim(x)[1]

#' ncol miRoar object
#'
#' ncol miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return subsetted miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
ncol.miRoar <- function(x) dim(x)[2]

#' rownames miRoar object
#'
#' rownames miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return rownames miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
getRownames <- function(x) rownames(x[['CtAvg']])

#' colnames miRoar object
#' colnames miRoar object
#'
#' @param x object to be subsetted
#' 
#' @return colnames miRoar object
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
getColnames <- function(x) colnames(x[['CtAvg']])

# broken
collapseMultipleReadings.miRoar <- function(x, method=c('mean', 'median'), na.rm=T){
    s <- Sys.time()
    history <- x$history
    method <- match.arg(method)

    woot <- lapply(x[-which(names(x) == 'history')], function(y, method, na.rm){
            if(is.matrix(y)){
                rn <- rownames(y)
                new <- t(sapply(unique(rn), function(i, y, method, na.rm){
                            res <- switch(method, 
                                'mean' = colMeans(t(as.matrix(y[rownames(y) %in% i, , drop=F])), na.rm=na.rm),
                                'median' = colMedians(t(as.matrix(y[rownames(y) %in% i,,drop=F])), na.rm=na.rm))
                            return(res)
                        },y=y, method=method, na.rm=na.rm))
                return(new)
            } else if(is.array(y)){
                rn <- rownames(y)
                new <- t(sapply(unique(rn), function(i, y, method, na.rm){
                            res <- switch(method, 
                                'mean' = colMeans(as.matrix(y[rownames(y) %in% i,, ,drop=F]), na.rm=na.rm),
                                'median' = colMedians(as.matrix(y[rownames(y) %in% i,,,drop=F]), na.rm=na.rm))
                            return(res)
                        },y=y, method=method, na.rm=na.rm))
                return(new)
            } else {
                return(y)
            }}, method=method, na.rm=na.rm)
    woot$history <- history
    class(woot) <- 'miRoar'
    woot <- updateHistory(woot, s, 'Used collapseMultipleReadings')
    return(woot)
}

#' Set Bad Signals to NA
#'
#' Set Bad Signals to NA
#'
#' @param x a miRoar object
#' @param maxCT a
#' @param minCT b
#' @param ampVal c
#' @param conf.val d
#' @return x
#'
#' @examples
#' # readEDS()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
setBadSignalsToNA.miRoar <- function(x, maxCT = 40, minCT = 0, ampVal = 0, conf.val = .8){
    s <- Sys.time()
    detp <- x$Con
    amps <- x$CrtAmp
    crts <- x$Crt
    toNA <- detp < conf.val | amps < ampVal | crts <= minCT | crts >= maxCT
    is.na(x$Ct) <- toNA
    is.na(x$CtAvg) <- toNA
    is.na(x$Crt) <- toNA
    x <- updateHistory(x, s, 'Set values to NA using thresholds:')
    return(x)
}

#' Remove Bad Signals
#'
#' Remove Bad Signals
#'
#' @param x a miRoar object
#' @param perc a
#' @return x
#'
#' @examples
#' # readEDS()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
removeBadSignals <- function(x, perc = 1) UseMethod('removeBadSignals', x)

#' Remove Bad Signals
#'
#' Remove Bad Signals
#'
#' @param x a miRoar object
#' @param perc a
#' @return x
#'
#' @examples
#' # readEDS()
#'
#' @author Tyler Gorrie-Stone \email{tgorri@essex.ac.uk}
#' @export
removeBadSignals.miRoar <- function(x, perc = 1){
    s <- Sys.time()
    z <- rowSums(is.na(x[['Crt']]))
    thresh <- ncol(x)*perc
    xx <- subset(x, i = !z >= 1)
    xx <- updateHistory(xx, s, 'Removed miRs with no signal')
    return(xx)
}

